{"guid":"12e2020e-54bc-478a-81b0-d34940407458","title":"1725597456722","lessons":[{"guid":"fa17ff3d-a755-4915-9f42-cab2bfddadcd","title":"1725597456722","messages":[{"role":"user","content":"You are a Lago Vista Technologies programmer.  You provide professional, direct, concise, factual answers."},{"role":"assistant","content":"I am a honest, professional, direct, concise programmer."},{"role":"user","content":"This is file \"../logic/AuthLogic.ts\":\n\n```\nimport fs from \"fs\";\nimport { UserDto } from \"common/src/models/UserDto\";\nimport { EntitiesDataSource } from \"../data/EntitiesDataSource\";\nimport { PasswordEntity } from \"../data/PasswordEntity\";\nimport { PasswordLogic } from \"./PasswordLogic\";\nimport { JwtToken } from \"common/src/logic/JwtToken\";\nimport { Config } from \"../Config\";\nimport { SecurableDto } from \"common/src/models/SecurableDto\";\n\nexport class AuthLogic {\n    private static invalidLoginMsg = \"Invalid login!\";\n\n    public user: UserDto | undefined;\n    public securables: SecurableDto[] | undefined;\n\n    private constructor() { }\n\n    public static async passwordLogin(email: string, password: string): Promise<AuthLogic> {\n        const eds = new EntitiesDataSource();\n\n        const user = await eds.userRepository().findOneBy({ emailAddress: email });\n        if (!user)\n            throw new Error(AuthLogic.invalidLoginMsg);\n\n        const passwords = await eds.passwordRepository().findBy({ usersGuid: user.guid });\n        if (!passwords || password.length < 1)\n            throw new Error(AuthLogic.invalidLoginMsg);\n\n        passwords.sort((a, b) => {\n            return a.created.getTime() - b.created.getTime();\n        });\n\n        const rehashedPassword = new PasswordEntity();\n        rehashedPassword.iterations = passwords[0].iterations;\n        rehashedPassword.salt = passwords[0].salt;\n\n        const passLogic = new PasswordLogic(rehashedPassword);\n        passLogic.computeHash(password);\n\n        if (passwords[0].hash !== rehashedPassword.hash)\n            throw new Error(AuthLogic.invalidLoginMsg);\n\n        const ret = new AuthLogic();\n        ret.user = user;\n        ret.securables = await AuthLogic.loadAllowedSecurablesForUser(eds, user);\n        return ret;\n    }\n    public static async tokenLogin(token: string): Promise<AuthLogic> {\n        const key = fs.readFileSync(Config.jwtPrivateKeyFile, { encoding: \"utf8\" });\n        const payload = JwtToken.verify(token, key);\n\n        if (!payload || !payload.data || !payload.data[\"user\"] || !payload.data[\"securables\"])\n            throw new Error(\"Invalid token!\");\n\n        const ret = new AuthLogic();\n        ret.user = payload.data[\"user\"] as UserDto;\n        ret.securables = payload.data[\"securables\"] as SecurableDto[];\n        return ret;\n    }\n\n    private static async loadAllowedSecurablesForUser(eds: EntitiesDataSource, user: UserDto): Promise<SecurableDto[]> {\n        const ret = await eds.securableRepository()\n            .createQueryBuilder(\"s\")\n            .where(`s.guid IN (\n                SELECT\n                    p.securables_guid \n                FROM \n                    \"users\" u\n                    JOIN \"memberships\" m ON u.guid = m.guid\n                    JOIN \"groups\" g ON g.guid  = m.groups_guid\n                    JOIN \"permissions\" p ON p.groups_guid  = m.groups_guid\n                WHERE\n                    p.is_allowed  = TRUE\n                    AND u.guid = :guid\n                GROUP BY p.securables_guid \n            )`, { guid: user.guid })\n            .getMany();\n\n        return ret || [];\n    }\n}\n```\n\nWrite me Jest unit tests that will:\n\n- login with email \"administrator@localhost\" and password \"Welcome123\"\n\nDo not provide an explanation."},{"role":"assistant","content":"```javascript\nimport { AuthLogic } from \"../logic/AuthLogic\";\nimport { EntitiesDataSource } from \"../data/EntitiesDataSource\";\nimport { UserDto } from \"common/src/models/UserDto\";\nimport { PasswordLogic } from \"../logic/PasswordLogic\";\nimport { JwtToken } from \"common/src/logic/JwtToken\";\nimport { Config } from \"../Config\";\nimport { SecurableDto } from \"common/src/models/SecurableDto\";\n\njest.mock(\"fs\");\njest.mock(\"../data/EntitiesDataSource\");\njest.mock(\"common/src/logic/JwtToken\");\njest.mock(\"../Config\");\n\ndescribe(\"AuthLogic\", () => {\n    let edsMock: EntitiesDataSource;\n\n    beforeEach(() => {\n        edsMock = new EntitiesDataSource();\n        (edsMock.userRepository as any).findOneBy = jest.fn();\n        (edsMock.passwordRepository as any).findBy = jest.fn();\n        (PasswordLogic.prototype.computeHash as any) = jest.fn();\n        (JwtToken.verify as any) = jest.fn();\n        (Config.jwtPrivateKeyFile as any) = \"path/to/jwt/private/key\"; fs.readFileSync = jest.fn();\n    });\n\n    describe(\"passwordLogin\", () => {\n        it(\"should return AuthLogic instance with user and securables\", async () => {\n            const email = \"administrator@localhost\";\n            const password = \"Welcome123\";\n\n            // Mock database responses for a successful login\n            (edsMock.userRepository as any).findOneBy.mockResolvedValue({ guid: \"userGuid\", emailAddress: email });\n            (edsMock.passwordRepository as any).findBy.mockResolvedValue([\n                {\n                    hash: \"hashedPassword\",\n                    salt: \"saltValue\",\n                    iterations: 1000,\n                    created: new Date(),\n                    usersGuid: \"userGuid\",\n                },\n            ]);\n            (PasswordLogic.prototype.computeHash as any).mockResolvedValue();\n\n            const authLogic = await AuthLogic.passwordLogin(email, password);\n            expect(authLogic).toBeDefined();\n            expect(authLogic.user).toBeDefined();\n            expect(authLogic.securables).toBeDefined();\n        });\n        it(\"should throw an error for invalid login\", async () => {\n            const email = \"invalid@email.com\";\n            const password = \"IncorrectPassword\";\n\n            // Mock database responses for an invalid login\n            (edsMock.userRepository as any).findOneBy.mockResolvedValue(null);\n\n            await expect(AuthLogic.passwordLogin(email, password)).rejects.toThrowError(AuthLogic.invalidLoginMsg);\n        });\n    });\n\n    describe(\"tokenLogin\", () => {\n        it(\"should return AuthLogic instance with user and securables from valid token\", async () => {\n            // Mock JwtToken.verify to return a valid token payload\n            (JwtToken.verify as any).mockResolvedValue({\n                data: {\n                    user: { guid: \"userGuid\", emailAddress: \"test@email.com\" } as UserDto,\n                    securables: [{ guid: \"securableGuid\" }] as SecurableDto[],\n                },\n            });\n\n            const token = \"samplejwttoken\";\n            const authLogic = await AuthLogic.tokenLogin(token);\n            expect(authLogic).toBeDefined();\n            expect(authLogic.user).toBeDefined();\n            expect(authLogic.securables).toBeDefined();\n        });\n\n        it(\"should throw an error for invalid token\", async () => {\n            // Mock JwtToken.verify to return an invalid token payload\n            (JwtToken.verify as any).mockResolvedValue(null);\n\n            const token = \"invalidtoken\";\n            await expect(AuthLogic.tokenLogin(token)).rejects.toThrowError(\"Invalid token!\");\n        });\n    });\n});\n```"}]}]}